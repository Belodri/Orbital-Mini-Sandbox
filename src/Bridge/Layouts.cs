using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;

namespace Bridge;

/// <summary>
/// Generates all layout configuration data for the C# memory writer and the JS memory reader from the record definitions in LayoutRecords.cs and their source-generated versions.
/// This ensures the design is DRY, there is a SSOT for the memory layout, and enables a type-safe, self-configuring JS reader.
/// </summary>
/// <remarks>
/// Uses minimal, AOT-safe reflection that runs only once during static initialization, ensuring no performance impact at runtime.
/// </remarks
internal static class Layouts
{
    /// <summary>
    /// An array of the property names of <see cref="SimStateLayout"/>.
    /// </summary>
    public static ReadOnlyCollection<string> SimKeys => _sim.Keys;
    /// <summary>
    /// An array of string names of C# types, where each element describes the type of the value of the property key in <see cref="SimKeys"/> of the same index.
    /// </summary>
    public static ReadOnlyCollection<string> SimCsTypes => _sim.CsTypes;
    /// <summary>
    /// An instance of the autogenerated record where each property holds its own integer index offset in the memory buffer (e.g. <c>SimMemLayout.timeStep == 1</c>) to avoid dictionary lookups when writing to the shared memory.
    /// </summary>
    public static SimStateLayoutRec SimMemLayout => _sim.MemLayout;
    /// <summary>
    /// An array of the property names of <see cref="BodyStateLayout"/>.
    /// </summary>
    public static ReadOnlyCollection<string> BodyKeys => _body.Keys;
    /// <summary>
    /// An array of string names of C# types, where each element describes the type of the value of the property key in <see cref="BodyKeys"/> of the same index.
    /// </summary>
    public static ReadOnlyCollection<string> BodyCsTypes => _body.CsTypes;
    /// <summary>
    /// An instance of the autogenerated record where each property holds its own integer index offset in the memory buffer (e.g. <c>BodyMemLayout.id == 0</c>) to avoid dictionary lookups when writing to the shared memory.
    /// </summary>
    public static BodyStateLayoutRec BodyMemLayout => _body.MemLayout;

    #region Private Implementation

    private static readonly LayoutData<SimStateLayout, SimStateLayoutRec> _sim = new();
    private static readonly LayoutData<BodyStateLayout, BodyStateLayoutRec> _body = new();

    private class LayoutData<
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TStateLayout,
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TMemLayoutRec
    >
        where TStateLayout : class
        where TMemLayoutRec : class
    {
        public readonly ReadOnlyCollection<string> Keys;
        public readonly ReadOnlyCollection<string> CsTypes;
        public readonly TMemLayoutRec MemLayout;

        public LayoutData()
        {
            var stateParams = typeof(TStateLayout).GetConstructors().Single().GetParameters();
            var memParams = typeof(TMemLayoutRec).GetConstructors().Single().GetParameters();

            if (stateParams.Length != memParams.Length)
                throw new InvalidOperationException($"Mismatch of number of constructor parameters between type {typeof(TStateLayout)} and its autogenerated type {typeof(TMemLayoutRec)}.");

            List<string> keys = [];
            List<string> csTypes = [];
            List<object> constructorArgs = [];

            for (int i = 0; i < stateParams.Length; i++)
            {
                var tParam = stateParams[i];
                var genParam = memParams[i];

                var key = tParam.Name ?? throw new InvalidOperationException($"Unnamed onstructor parameter in type {typeof(TStateLayout)}");
                if (key != genParam.Name) throw new InvalidOperationException($"Mismatch match of constructor parameter {key} in type {typeof(TStateLayout)} and its autogenerated type {typeof(TMemLayoutRec)}.");

                var type = tParam.ParameterType;

                keys.Add(key);
                csTypes.Add(type.Name); // "Boolean" | "Double" | "Int32"
                constructorArgs.Add(i);
            }

            Keys = keys.AsReadOnly();
            CsTypes = csTypes.AsReadOnly();

            MemLayout = (TMemLayoutRec)typeof(TMemLayoutRec).GetConstructors().Single().Invoke([.. constructorArgs])
                ?? throw new InvalidCastException($"Failed to generate {nameof(MemLayout)}: Unable to cast constructed object into type {typeof(TMemLayoutRec)}.");
        }
    }

    #endregion
}
