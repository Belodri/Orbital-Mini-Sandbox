using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Physics;

namespace Bridge;

internal class MemoryBufferHandler : IDisposable
{
    // Pointers
    private nint _simBufferPtr;
    private nint _bodyBufferPtr;
    // Public Accessors
    public nint SimBufferPtr => _simBufferPtr;
    public nint BodyBufferPtr => _bodyBufferPtr;

    // Sizes in bytes
    private readonly int _simBufferSizeInBytes;
    private int _bodyBufferSizeInBytes;
    // Public Accessors
    public int SimBufferSizeInBytes => _simBufferSizeInBytes;
    public int BodyBufferSizeInBytes => _bodyBufferSizeInBytes;

    // Capacity in number of bodies
    private int _bodyCapacity;

    // Staging buffer for GC efficient memory writes
    private double[] _bodiesStagingBuffer;

    #region Static Dynamic Layout Creation

    /*
        This region contains the logic to automatically generate all necessary layout configurations
        from the record definitions in LayoutRecords.cs and their autogenerated versions. 
        This ensures the design is DRY and that there is a SSOT for the memory layout.

        This process creates three artifacts for each layout:
            1. A `string[]` (e.g., `SimStateLayoutArr`): An array of the property names.
                This is exported to JavaScript, allowing the JS side to understand the data structure
                without hardcoded values.

            2. A `string[]` (e.g., `SimStateTsTypes`): An array of the JS types of the properties, in the same order as the 1st artifact.
                This is also exported to JavaScript, allowing the JS side to correctly differentiate between numbers and booleans.

            3. An instance of the autogenerated record itself (e.g., `SimStateLayout`): A strongly-typed object
                where each property holds its own integer index (e.g., `SimStateLayout._bodyBufferPtr` will be 0).
                This is used internally by the C# hot path for maximum performance, avoiding dictionary lookups.
        
        This is achieved using minimal, AOT-safe reflection that runs only once during static initialization,
        ensuring no performance impact at runtime.
    */

    // Layout for Float64 buffer for JS reader.
    public static readonly string[] SimStateLayoutArr = GetRecordKeys<SimStateLayoutRec>();
    public static readonly string[] BodyStateLayoutArr = GetRecordKeys<BodyStateLayoutRec>();

    // Types for values in Float64 buffer for JS reader.
    public static readonly string[] SimStateTsTypes = GetTsTypes<SimStateLayout>(SimStateLayoutArr);
    public static readonly string[] BodyStateTsTypes = GetTsTypes<BodyStateLayout>(BodyStateLayoutArr);

    // Layout for Float64 buffer for C# writer.
    public static readonly SimStateLayoutRec SimStateLayoutRec = CreateInstanceFromLayout<SimStateLayoutRec>(SimStateLayoutArr);
    public static readonly BodyStateLayoutRec BodyStateLayoutRec = CreateInstanceFromLayout<BodyStateLayoutRec>(BodyStateLayoutArr);

    /// <summary>
    /// Creates an array of property names (keys) from a record type.
    /// This method is compatible with trimming and Native AOT.
    /// </summary>
    /// <typeparam name="TRec">The record or class type to inspect.</typeparam>
    /// <returns>A string array containing the names of the record's public, declared properties.</returns>
    private static string[] GetRecordKeys<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TRec>() where TRec : class
    {
        return [.. typeof(TRec)
            .GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .Select(p => p.Name)];
    }

    private static string[] GetTsTypes<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(string[] recLayoutArr) where T : class
    {
        var constrParams = typeof(T).GetConstructors().Single().GetParameters();
        if (constrParams.Length != recLayoutArr.Length) throw new InvalidOperationException($"Invalid match of record keys between type {typeof(T)} and its autogenerated type.");

        var boolType = typeof(bool);
        var doubleType = typeof(double);
        var intType = typeof(int);

        // Guarantee that type strings are in the exact same order as their respective memory offsets.
        string[] typeStrings = new string[recLayoutArr.Length];
        for (int i = 0; i < recLayoutArr.Length; i++)
        {
            var param = constrParams[i];
            if (param.Name != recLayoutArr[i]) throw new InvalidOperationException($"Invalid match of record key {param.Name} with autogenerated record key {recLayoutArr[i]}");

            var type = param.ParameterType;

            typeStrings[i] = type == doubleType || type == intType ? "number"
                : type == boolType ? "boolean"
                    : throw new InvalidOperationException($"Invalid type {type} on record type {typeof(T)}");
        }

        return typeStrings;
    }

    /// <summary>
    /// Creates an instance of a record type from a layout array.
    /// The value for each property is set to the index of its name in the layout array.
    /// </summary>
    /// <typeparam name="TRec">The record type to create. Must have a single public constructor with only int parameters.</typeparam>
    /// <param name="recLayout">An array of strings where each string is a property name of the record.</param>
    /// <returns>A new instance of the record T.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the record does not have a single, unique public constructor.</exception>
    private static TRec CreateInstanceFromLayout<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TRec>(string[] recLayout) where TRec : class
    {
        var constructor = typeof(TRec).GetConstructors().Single();
        var constructorParams = constructor.GetParameters();

        var arguments = constructorParams.Select(param =>
        {
            int index = Array.IndexOf(recLayout, param.Name);
            return (object)index;
        }).ToArray();

        return (TRec)constructor.Invoke(arguments);
    }

    #endregion

    public MemoryBufferHandler(int initialBodyCapacity = 10)
    {
        if (initialBodyCapacity <= 0)
            throw new ArgumentException("Initial body capacity must be positive", nameof(initialBodyCapacity));

        _bodyCapacity = initialBodyCapacity;

        // Calculate the required size for the buffers.
        unsafe
        {
            _simBufferSizeInBytes = SimStateLayoutArr.Length * sizeof(double);
            _bodyBufferSizeInBytes = BodyStateLayoutArr.Length * sizeof(double) * _bodyCapacity;
        }

        // Allocate the unmanaged memory. Marshal.AllocHGlobal returns an IntPtr, which we store in our nint field.
        _simBufferPtr = Marshal.AllocHGlobal(_simBufferSizeInBytes);
        _bodyBufferPtr = Marshal.AllocHGlobal(_bodyBufferSizeInBytes);

        // Setup the staging buffer with the initial capacity
        _bodiesStagingBuffer = new double[_bodyCapacity * BodyStateLayoutArr.Length];
    }

    #region Data Writing

    internal void WriteViewToMemory(SimulationView view)
    {
        // Resize if needed
        EnsureBodyCapacity(view.Bodies.Count);
        WriteFixedBuffer(view);
        WriteDynamicBuffer(view.Bodies);
    }

    private unsafe void WriteFixedBuffer(SimulationView view)
    {
        double* pSimState = (double*)_simBufferPtr;

        pSimState[SimStateLayoutRec.simulationTime] = view.SimulationTime;
        pSimState[SimStateLayoutRec.timeStep] = view.TimeStep;
        pSimState[SimStateLayoutRec.bodyCount] = view.Bodies.Count;
        pSimState[SimStateLayoutRec.theta] = view.Theta;
        pSimState[SimStateLayoutRec.gravitationalConstant] = view.G_SI;
        pSimState[SimStateLayoutRec.epsilon] = view.Epsilon;
    }

    public unsafe void WriteDynamicBuffer(IReadOnlyList<BodyView> bodies)
    {
        int bodyCount = bodies.Count;
        if (bodyCount == 0) return;

        int bodyStride = BodyStateLayoutArr.Length;
        int totalDoubles = bodyCount * bodyStride;

        // Span to represent only the used portion of the reusable array.
        var allBodiesData = new Span<double>(_bodiesStagingBuffer, 0, totalDoubles);

        for (int i = 0; i < bodyCount; i++)
        {
            BodyView body = bodies[i];
            var bodySlice = allBodiesData.Slice(i * bodyStride, bodyStride);

            bodySlice[BodyStateLayoutRec.id] = body.Id;
            bodySlice[BodyStateLayoutRec.enabled] = body.Enabled ? 1.0 : 0.0;
            bodySlice[BodyStateLayoutRec.mass] = body.Mass;
            bodySlice[BodyStateLayoutRec.posX] = body.Position.X;
            bodySlice[BodyStateLayoutRec.posY] = body.Position.Y;
            bodySlice[BodyStateLayoutRec.velX] = body.Velocity.X;
            bodySlice[BodyStateLayoutRec.velY] = body.Velocity.Y;
            bodySlice[BodyStateLayoutRec.accX] = body.Acceleration.X;
            bodySlice[BodyStateLayoutRec.accY] = body.Acceleration.Y;
            bodySlice[BodyStateLayoutRec.outOfBounds] = body.OutOfBounds ? 1.0 : 0.0;
        }

        fixed (double* pSource = allBodiesData)
        {
            Unsafe.CopyBlock((double*)_bodyBufferPtr, pSource, (uint)(totalDoubles * sizeof(double)));
        }
    }

    internal void EnsureBodyCapacity(int requiredBodyCount)
    {
        if (requiredBodyCount <= _bodyCapacity) return;

        int newCapacity = _bodyCapacity;
        while (newCapacity < requiredBodyCount) { newCapacity *= 2; }
        _bodyCapacity = newCapacity;

        int bodyStride = BodyStateLayoutArr.Length;
        int newSizeInBytes;
        unsafe { newSizeInBytes = bodyStride * sizeof(double) * _bodyCapacity; }

        // Reallocate the unmanaged memory block.
        _bodyBufferPtr = Marshal.ReAllocHGlobal(_bodyBufferPtr, newSizeInBytes);
        _bodyBufferSizeInBytes = newSizeInBytes;

        // Resize the staging buffer to match capacity.
        _bodiesStagingBuffer = new double[_bodyCapacity * bodyStride];
    }

    #endregion


    #region IDisposable implementation

    private bool _disposed = false;

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            // Clean up unmanaged resources.
            if (_simBufferPtr != nint.Zero)
            {
                Marshal.FreeHGlobal(_simBufferPtr);
                _simBufferPtr = nint.Zero;
            }

            if (_bodyBufferPtr != nint.Zero)
            {
                Marshal.FreeHGlobal(_bodyBufferPtr);
                _bodyBufferPtr = nint.Zero;
            }

            _disposed = true;
        }
    }

    ~MemoryBufferHandler() => Dispose(false);

    #endregion
}