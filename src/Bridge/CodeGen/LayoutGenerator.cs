using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace CodeGen;

/// <summary>
/// Source generator to create layout records.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class LayoutGenerator : IIncrementalGenerator
{
    private const string AttributeName = "Attributes.GenerateLayoutRecord";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all records with the attribute.
        IncrementalValuesProvider<INamedTypeSymbol> recordSymbols = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeName,
                // Only work with record declarations.
                predicate: static (node, _) => node is RecordDeclarationSyntax,
                // Transform the syntax context to the semantic symbol for the record.
                transform: static (context, _) => (INamedTypeSymbol)context.TargetSymbol);

        context.RegisterSourceOutput(recordSymbols, static (spc, symbol) =>
        {
            /*             
            var descriptor = new DiagnosticDescriptor(
                "SG001",
                "Generator Found Record",
                $"LayoutGenerator found the record: '{symbol.Name}' with {symbol.InstanceConstructors.Length} constructors.",
                "Generator",
                DiagnosticSeverity.Warning,
                true
            );
            spc.ReportDiagnostic(Diagnostic.Create(descriptor, symbol.Locations.FirstOrDefault()));
             */
            
            var srcCode = GenerateLayoutRecordSource(symbol);
            if (srcCode is null || srcCode == "") return;
            spc.AddSource($"{symbol.Name}Rec.g.cs", srcCode);
        });

    }
    
    /// <summary>
    /// Generates the source code for the new layout record.
    /// </summary>
    /// <param name="recordSymbol">The symbol of the original record.</param>
    /// <returns>Generated C# code as a string.</returns>
    private static string? GenerateLayoutRecordSource(INamedTypeSymbol recordSymbol)
    {
        // Determine the namespace of the original record to place the new record in the same one.
        var namespaceName = recordSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : $"namespace {recordSymbol.ContainingNamespace.ToDisplayString()};";

        var recordName = recordSymbol.Name;
        var newRecordName = $"{recordName}Rec";

        var builder = new StringBuilder();
        builder.AppendLine($"// <auto-generated/>");
        builder.AppendLine(namespaceName);
        builder.AppendLine();
        builder.AppendLine($"public record {newRecordName}(");

        var primConstr = recordSymbol.InstanceConstructors
            .SingleOrDefault(ctor => ctor.DeclaringSyntaxReferences.Any(
                syntaxRef => syntaxRef.GetSyntax() is RecordDeclarationSyntax
            ));
        if (primConstr == null) return null;
        var constructorParameters = primConstr.Parameters;

        for (int i = 0; i < constructorParameters.Length; i++)
        {
            var parameter = constructorParameters[i];
            // Create the new field with the original name but as an 'int' type.
            builder.Append($"    int {parameter.Name}");
            if (i < constructorParameters.Length - 1)
            {
                builder.AppendLine(",");
            }
            else
            {
                builder.AppendLine();
            }
        }
        
        builder.AppendLine(");");
        return builder.ToString();
    }
}