using System.Runtime.InteropServices.JavaScript;
using System.Text.Json;
using System.Text.Json.Serialization;
using Physics;

namespace Bridge;

internal class Program { private static void Main(string[] args) { } }  // Called while initializing dotnet.js; Don't remove!

[JsonSourceGenerationOptions(
    WriteIndented = false,
    GenerationMode = JsonSourceGenerationMode.Metadata,
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
[JsonSerializable(typeof(PresetData))]
[JsonSerializable(typeof(PresetSimData))]
[JsonSerializable(typeof(PresetBodyData))]
[JsonSerializable(typeof(PresetBodyData[]))]
partial class PresetJSONSerializerContext : JsonSerializerContext { }

public static partial class EngineBridge
{

    private static readonly PhysicsEngine physicsEngine;
    private static readonly MemoryBufferHandler memoryBufferHandler;
    private static readonly CommandQueue commandQueue;

    static EngineBridge()
    {
        physicsEngine = new PhysicsEngine();
        memoryBufferHandler = new MemoryBufferHandler();
        commandQueue = new CommandQueue();
    }

    #region Bridge-internal methods

    [JSExport]
    public static string[] GetSimStateLayout() => MemoryBufferHandler.SimStateLayoutArr;

    [JSExport]
    public static string[] GetBodyStateLayout() => MemoryBufferHandler.BodyStateLayoutArr;

    [JSExport]
    public static int[] GetSimBufferPtrAndSize()
    {
        return [
            (int)memoryBufferHandler.SimBufferPtr,
            memoryBufferHandler.SimBufferSizeInBytes,
        ];
    }

    #endregion

    #region Publicly exposed methods

    [JSExport]
    public static void Tick(double timestamp)
    {
        // Process queued commands
        commandQueue.ProcessAll(physicsEngine);
        // Let the engine do its calculations
        TickData tickData = physicsEngine.Tick(timestamp);
        // Write the resulting state into the shared memory
        memoryBufferHandler.WriteTickData(tickData);
        // Resolve the queued commands
        commandQueue.ResolveProcessed();
    }

    [JSExport]
    public static Task<int> CreateBody()
    {
        return commandQueue.EnqueueTask(engine => engine.CreateBody());
    }

    [JSExport]
    public static Task<bool> DeleteBody(int id)
    {
        return commandQueue.EnqueueTask(engine => engine.DeleteBody(id));
    }

    // TODO Consider refactor to using delta values in updates
    [JSExport]
    public static Task<bool> UpdateBody(int id, bool? enabled, double? mass, double? posX, double? posY, double? velX, double? velY)
    {
        return commandQueue.EnqueueTask(engine =>
        {
            return physicsEngine.UpdateBody(
                new(id, enabled, mass, posX, posY, velX, velY)
            );
        });
    }

    /// <summary>
    /// Serializes the current state of the physics simulation into a JSON string.
    /// </summary>
    /// <returns>
    /// A JSON formatted string representing the current <see cref="PresetData"/>. 
    /// This string can be saved and later loaded using the <see cref="LoadPreset"/> method.
    /// </returns>
    [JSExport]
    public static string GetPreset()
    {
        PresetData data = physicsEngine.GetPresetData();
        return CreatePresetString(data);
    }

    internal static string CreatePresetString(PresetData presetData)
    {
        return JsonSerializer.Serialize(presetData, PresetJSONSerializerContext.Default.PresetData);
    }


    /// <summary>
    /// Deserializes a JSON string representing a simulation preset and applies it to the physics engine,
    /// overwriting the current simulation state.
    /// </summary>
    /// <param name="jsonPreset">A string containing the simulation state in JSON format generated by the <see cref="GetPreset"/> method.</param>
    [JSExport]
    public static void LoadPreset(string jsonPreset)
    {
        commandQueue.ClearQueue(); // Ensure prior commands cannot interfere with the newly loaded state.
        PresetData? data = ParseJsonPreset(jsonPreset) ?? throw new Exception("Failed to load: Preset data was null or empty.");
        TickData tickData = physicsEngine.LoadPreset(data);
        memoryBufferHandler.WriteTickData(tickData);
    }

    internal static PresetData? ParseJsonPreset(string jsonPreset)
    {
        PresetData? data = JsonSerializer.Deserialize(
                jsonPreset,
                PresetJSONSerializerContext.Default.PresetData
            );
        return data;
    }

    #endregion
}
