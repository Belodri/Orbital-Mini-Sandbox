using System.Runtime.InteropServices.JavaScript;
using System.Text.Json;
using System.Text.Json.Serialization;
using Physics;

namespace Bridge;

internal class Program { private static void Main(string[] args) { } }  // Called while initializing dotnet.js; Don't remove!

internal record PresetData(SimDataBase Sim, List<BodyDataBase> Bodies);

[JsonSourceGenerationOptions(
    WriteIndented = false,
    GenerationMode = JsonSourceGenerationMode.Metadata,
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
[JsonSerializable(typeof(PresetData))]
[JsonSerializable(typeof(SimDataBase))]
[JsonSerializable(typeof(BodyDataBase))]
[JsonSerializable(typeof(List<BodyDataBase>))]
partial class PresetJSONSerializerContext : JsonSerializerContext { }

public static partial class EngineBridge
{

    private static readonly PhysicsEngine physicsEngine;
    private static readonly MemoryBufferHandler memoryBufferHandler;
    private static readonly CommandQueue commandQueue;

    static EngineBridge()
    {
        physicsEngine = new PhysicsEngine();
        memoryBufferHandler = new MemoryBufferHandler();
        commandQueue = new CommandQueue();
    }

    #region Bridge-internal methods

    [JSExport]
    public static string[] GetSimStateLayout() => MemoryBufferHandler.SimStateLayoutArr;

    [JSExport]
    public static string[] GetBodyStateLayout() => MemoryBufferHandler.BodyStateLayoutArr;

    [JSExport]
    public static int[] GetSimBufferPtrAndSize()
    {
        return [
            (int)memoryBufferHandler.SimBufferPtr,
            memoryBufferHandler.SimBufferSizeInBytes,
        ];
    }

    #endregion

    #region Publicly exposed methods

    [JSExport]
    public static void Tick(double realDeltaTimeMs)
    {
        // Process queued commands
        commandQueue.ProcessAll(physicsEngine);
        // Let the engine do its calculations
        physicsEngine.Tick(realDeltaTimeMs);
        // Get the tick data

        (SimDataFull sim, List<BodyDataFull> bodies) = physicsEngine.GetFullData();
        // Write the resulting state into the shared memory
        memoryBufferHandler.WriteTickData(sim, bodies);
        // Resolve the queued commands
        commandQueue.ResolveProcessed();
    }

    [JSExport]
    public static Task<int> CreateBody()
    {
        return commandQueue.EnqueueTask(engine => engine.CreateBody());
    }

    [JSExport]
    public static Task<bool> DeleteBody(int id)
    {
        return commandQueue.EnqueueTask(engine => engine.DeleteBody(id));
    }

    [JSExport]
    public static Task<bool> UpdateBody(
        int id,
        bool? enabled, double? mass,
        double? posX, double? posY,
        double? velX, double? velY,
        double? accX, double? accY)
    {
        return commandQueue.EnqueueTask(engine =>
        {
            return physicsEngine.UpdateBody(
                id, new(enabled, mass, posX, posY, velX, velY, accX, accY)
            );
        });
    }

    /// <summary>
    /// Serializes the current state of the physics simulation into a JSON string.
    /// </summary>
    /// <returns>
    /// A JSON formatted string representing the current <see cref="PresetData"/>. 
    /// This string can be saved and later loaded using the <see cref="LoadPreset"/> method.
    /// </returns>
    [JSExport]
    public static string GetPreset()
    {
        (SimDataBase sim, List<BodyDataBase> bodies) = physicsEngine.GetBaseData();
        PresetData data = new(sim, bodies);
        return CreatePresetString(data);
    }

    internal static string CreatePresetString(PresetData presetData)
    {
        return JsonSerializer.Serialize(presetData, PresetJSONSerializerContext.Default.PresetData);
    }


    /// <summary>
    /// Deserializes a JSON string representing a simulation preset and applies it to the physics engine,
    /// overwriting the current simulation state.
    /// </summary>
    /// <param name="jsonPreset">A string containing the simulation state in JSON format generated by the <see cref="GetPreset"/> method.</param>
    [JSExport]
    public static void LoadPreset(string jsonPreset)
    {
        commandQueue.ClearQueue(); // Ensure prior commands cannot interfere with the newly loaded state.
        PresetData? data = ParseJsonPreset(jsonPreset) ?? throw new Exception("Failed to load: Preset data was null or empty.");
        physicsEngine.Load(data.Sim, data.Bodies);
        Tick(0);
    }

    internal static PresetData? ParseJsonPreset(string jsonPreset)
    {
        PresetData? data = JsonSerializer.Deserialize(
                jsonPreset,
                PresetJSONSerializerContext.Default.PresetData
            );
        return data;
    }

    #endregion
}
